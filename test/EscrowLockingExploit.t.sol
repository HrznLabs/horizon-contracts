// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import { Test, console } from "forge-std/Test.sol";
import { MissionFactory } from "../src/MissionFactory.sol";
import { MissionEscrow } from "../src/MissionEscrow.sol";
import { PaymentRouter } from "../src/PaymentRouter.sol";
import { DisputeResolver } from "../src/DisputeResolver.sol";
import { IMissionEscrow } from "../src/interfaces/IMissionEscrow.sol";
import { IDisputeResolver } from "../src/interfaces/IDisputeResolver.sol";
import { MockERC20 } from "./mocks/MockERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract EscrowLockingExploit is Test {
    using SafeERC20 for MockERC20;

    MissionFactory public factory;
    PaymentRouter public paymentRouter;
    DisputeResolver public resolver;
    MockERC20 public usdc;

    address public owner = address(0x1);
    address public poster = address(0x2);
    address public performer = address(0x3);
    address public resolversDAO = address(0x4);

    address public protocolTreasury = address(0x10);
    address public resolverTreasury = address(0x11);
    address public labsTreasury = address(0x12);

    uint256 public constant REWARD_AMOUNT = 100e6; // 100 USDC

    function setUp() public {
        vm.startPrank(owner);
        usdc = new MockERC20("USDC", "USDC", 6);

        paymentRouter = new PaymentRouter(address(usdc), protocolTreasury, resolverTreasury, labsTreasury);

        resolver = new DisputeResolver(
            address(usdc), resolversDAO, address(0x5), protocolTreasury, resolverTreasury
        );

        factory = new MissionFactory(address(usdc), address(paymentRouter));
        factory.setDisputeResolver(address(resolver));

        vm.stopPrank();

        // Mint USDC
        usdc.mint(poster, 1000e6);
        usdc.mint(performer, 1000e6);

        vm.prank(poster);
        usdc.approve(address(factory), 1000e6);

        vm.prank(poster);
        usdc.approve(address(resolver), 1000e6);

        vm.prank(performer);
        usdc.approve(address(resolver), 1000e6);
    }

    function test_Exploit_Fixed_RevertOnDirectCall() public {
        // 1. Poster creates mission
        vm.prank(poster);
        uint256 missionId = factory.createMission(
            REWARD_AMOUNT,
            block.timestamp + 1 days,
            address(0),
            bytes32(0),
            bytes32(0)
        );

        address escrowAddress = factory.missions(missionId);
        MissionEscrow escrow = MissionEscrow(escrowAddress);

        // 2. Performer accepts
        vm.prank(performer);
        escrow.acceptMission();

        // 3. Performer submits proof
        vm.prank(performer);
        escrow.submitProof(keccak256("proof"));

        // 4. Performer tries to raise dispute directly on Escrow
        // Should revert with NotDisputeResolver
        vm.prank(performer);
        vm.expectRevert(IMissionEscrow.NotDisputeResolver.selector);
        escrow.raiseDispute(keccak256("reason"));

        // Verify state is NOT Disputed
        IMissionEscrow.MissionRuntime memory runtime = escrow.getRuntime();
        assertEq(uint(runtime.state), uint(IMissionEscrow.MissionState.Submitted));
        assertFalse(runtime.disputeRaised);
    }

    function test_LegitimateDispute_AcceptedState() public {
        // 1. Poster creates mission
        vm.prank(poster);
        uint256 missionId = factory.createMission(
            REWARD_AMOUNT,
            block.timestamp + 1 days,
            address(0),
            bytes32(0),
            bytes32(0)
        );

        address escrowAddress = factory.missions(missionId);
        MissionEscrow escrow = MissionEscrow(escrowAddress);

        // 2. Performer accepts
        vm.prank(performer);
        escrow.acceptMission();

        // 3. State is Accepted. Performer wants to dispute (e.g. Poster is unresponsive or abusive)
        // Performer calls DisputeResolver directly

        uint256 ddrAmount = (REWARD_AMOUNT * resolver.getDDRRate()) / 10000;
        uint256 performerBalanceBefore = usdc.balanceOf(performer);

        vm.prank(performer);
        uint256 disputeId = resolver.createDispute(escrowAddress, missionId, keccak256("evidence"));

        uint256 performerBalanceAfter = usdc.balanceOf(performer);
        assertEq(performerBalanceBefore - performerBalanceAfter, ddrAmount); // DDR Paid

        // 4. Verify Escrow state updated to Disputed
        IMissionEscrow.MissionRuntime memory runtime = escrow.getRuntime();
        assertEq(uint(runtime.state), uint(IMissionEscrow.MissionState.Disputed));
        assertTrue(runtime.disputeRaised);

        // 5. Verify DisputeResolver has dispute
        IDisputeResolver.Dispute memory dispute = resolver.getDispute(disputeId);
        assertEq(dispute.escrowAddress, escrowAddress);
        assertEq(dispute.initiator, performer);
    }
}
