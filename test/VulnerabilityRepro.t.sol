// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console} from "forge-std/Test.sol";
import {MissionFactory} from "../src/MissionFactory.sol";
import {MissionEscrow} from "../src/MissionEscrow.sol";
import {PaymentRouter} from "../src/PaymentRouter.sol";
import {IMissionEscrow} from "../src/interfaces/IMissionEscrow.sol";
import {MockERC20} from "./mocks/MockERC20.sol";

contract VulnerabilityRepro is Test {
    MissionFactory public factory;
    PaymentRouter public router;
    MockERC20 public usdc;

    address public owner = address(1);
    address public poster = address(2);
    address public performer = address(3);
    address public attacker = address(999);
    address public protocolTreasury = address(4);
    address public resolverTreasury = address(5);
    address public labsTreasury = address(6);

    uint256 public constant REWARD_AMOUNT = 100e6; // 100 USDC
    bytes32 public constant METADATA_HASH = keccak256("metadata");
    bytes32 public constant LOCATION_HASH = keccak256("location");
    bytes32 public constant DISPUTE_HASH = keccak256("dispute");

    function setUp() public {
        vm.startPrank(owner);
        usdc = new MockERC20("USD Coin", "USDC", 6);
        router = new PaymentRouter(address(usdc), protocolTreasury, resolverTreasury, labsTreasury);
        factory = new MissionFactory(address(usdc), address(router));
        factory.setDisputeResolver(address(888)); // Valid resolver
        router.setMissionFactory(address(factory));
        vm.stopPrank();
        usdc.mint(poster, 1000e6);
    }

    function test_Exploit_UnauthorizedDisputeSettlement_Reverts() public {
        // 1. Setup Mission
        vm.startPrank(poster);
        usdc.approve(address(factory), REWARD_AMOUNT);
        uint256 missionId = factory.createMission(
            REWARD_AMOUNT,
            block.timestamp + 1 days,
            address(0),
            METADATA_HASH,
            LOCATION_HASH
        );
        vm.stopPrank();

        address escrowAddress = factory.missions(missionId);
        IMissionEscrow escrow = IMissionEscrow(escrowAddress);

        // 2. Performer accepts and submits
        vm.startPrank(performer);
        escrow.acceptMission();
        escrow.submitProof(keccak256("proof"));
        vm.stopPrank();

        // 3. Poster raises dispute
        vm.startPrank(poster);
        escrow.raiseDispute(DISPUTE_HASH);
        vm.stopPrank();

        // Verify state is Disputed
        assertEq(uint8(escrow.getRuntime().state), uint8(IMissionEscrow.MissionState.Disputed));

        // 4. ATTACK: Random user calls settleDispute
        vm.startPrank(attacker);

        // Should revert because attacker is not the dispute resolver (address(888))
        vm.expectRevert(IMissionEscrow.NotDisputeResolver.selector);
        escrow.settleDispute(1, 0);

        vm.stopPrank();

        console.log("Exploit prevented: Attacker could not settle dispute");
    }
}
